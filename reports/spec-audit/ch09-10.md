# Chapter 9–10 spec audit (high-confidence mismatches only)

## 1) `ProjectRegistry` write-path behavior is overstated

**Old (TECHNICAL_SPECIFICATION.md §9.2):**
> The `ProjectRegistry` class loads and manages project configurations with PostgreSQL synchronization on startup. Junction tables (`project_slides`, `project_models`) provide many-to-many relationships.

**New (suggested):**
> The `ProjectRegistry` class loads `foundation_models`, `classification_models`, and `projects` from YAML at startup. PostgreSQL synchronization is performed during app startup (`db.populate_projects_from_registry(...)`). Note: current `ProjectRegistry.save()` persists only the `projects` section, so API create/update/delete flows do not preserve top-level model catalogs.

---

## 2) Frontend “all labels/models/features configured” claim is too broad

**Old (§9.3 step 7):**
> **Restart the server.** The new project auto-loads in the frontend project switcher with all labels, models, and features configured

**New (suggested):**
> **Restart the server.** The new project auto-loads in the frontend project switcher with project labels and scoped models; feature-toggle-driven panel gating is not currently wired in the frontend.

---

## 3) “Frontend renders entirely from project metadata” is inaccurate

**Old (§9.3):**
> The frontend renders entirely from project metadata: class names, positive/negative labels, model lists, feature availability, and threshold values all derive from the YAML. No frontend code is aware of specific cancer types or model names.

**New (suggested):**
> The frontend is project-aware for switching and model scoping, but not entirely metadata-driven: it still contains hardcoded fallbacks (e.g., `DEFAULT_PROJECT` and label-mapping heuristics), and feature/threshold wiring is not fully derived from project metadata.

---

## 4) Project-switching bullets overstate threshold/feature behavior

**Old (§9.4 bullets 3–4):**
> 3. Labels, class names, and threshold values update to match the project config  
> 4. Feature panels show/hide based on project feature toggles

**New (suggested):**
> 3. Labels/class names and project-scoped model choices update with the selected project; threshold values are not currently propagated from `/api/projects` summaries in the frontend.  
> 4. Feature toggles are present in YAML/backend config but are not currently used to conditionally render panels in `frontend/src/app/page.tsx`.

---

## 5) Outlier detector is not project-scoped as written

**Old (§10.1):**
> The outlier detector identifies morphologically unusual tissue patches by measuring each patch's distance from the embedding centroid. It operates on whatever foundation model embeddings are configured for the active project. No model-specific code is required.

**New (suggested):**
> The outlier detector identifies morphologically unusual tissue patches by measuring each patch's distance from the embedding centroid. Current implementation loads `{slide_id}.npy` from the global `embeddings_dir` and does not take `project_id`, so this endpoint is not project-scoped.

---

## 6) Few-shot classifier is not project-scoped as written

**Old (§10.2):**
> The few-shot classifier enables pathologists to define custom tissue classes by selecting example patches, then classifies all patches in the slide. It operates on the active project's foundation model embeddings, making it compatible with any registered foundation model.

**New (suggested):**
> The few-shot classifier enables pathologists to define custom tissue classes by selecting example patches, then classifies all patches in the slide. Current implementation loads embeddings from the global `embeddings_dir` by `slide_id` and does not take `project_id`, so it is not project-scoped.

---

## 7) Spatial-selection UX description does not match current mounted UI

**Old (§10.2, “Spatial Selection Mode”):**
> The frontend supports click-to-select on the WSI viewer:
> 1. User creates class names in PatchClassifierPanel
> 2. Clicks "Select on Map" for a class, entering spatial selection mode
> 3. Clicks on the WSI viewer. The nearest patch (by coordinate) is added to the class
> 4. Patch coordinates are loaded via `GET /api/slides/{id}/patch-coords`
> 5. Selected patches highlighted with class-specific colors on the viewer

**New (suggested):**
> Backend and component-level support exists for spatial selection (`GET /api/slides/{id}/patch-coords`, nearest-patch snapping in `WSIViewer`, class select button text: `Select`). However, `PatchClassifierPanel` is currently not mounted in the main page (marked disabled), so this workflow is not user-accessible by default.
